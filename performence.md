# 性能优化

> 学习网站：web.dev

现在的性能优化方案很多，但是我们不能盲目的去做很多的性能优化工作，这样会耗费很多时间和精力，最后可能还会白费工夫，所以我们需要根据一个性能指标规划好性能优化的方案  
chrome Lighthouse规则，前端的性能指标有：

- FCP(First Contentful Paint):首次内容绘制时间，即浏览器首次绘制任何文本，图像，非空白canvas或svg的时间。
- SI(Speed Index):速度指数，即页面渲染速度的指标
- LCP(Larget Contentful Paint):最大内容绘制时间，即页面中最大的可见内容元素绘制完成的时间。
- TBT(total blocking time): 总阻塞时间，即页面主线程被阻塞的总时间
- CLS(cumulative layout shift)：累计布局偏移，即页面上所有元素在视觉上发生的意外移动的总和
- TTI(time to interactive)：TTI是指页面变得可交互所需的时间
- TTD(Time to display)：TTD是指页面显示所需的时间

其中，我们需要重点关注的是FCP,LCP,TTI  

有了标准以后，我们再进行性能检测，确认我们项目中最需要优化的地方  
性能检测的方式有以下几种：

- lightouse
- performance API 检测, 现在是用`performance.getEntriesByType()`api来查看，例如：`performance.getEntriesByType('navigation')[0].toJSON()` 可以查看navigation的性能参数
- 控制台 devtools
- node 侧：ab 压力测试端口+node --prof 启动会创建 log 日志 之后 使用 node --prof-process 生成耗时日志

## FCP的优化  


想要优化FCP，首先需要直到浏览器的渲染流程：  
1. 解析HTML形成DOM树  
2. 解析CSS形成CSSOM树  
3. DOM树和CSSOM树形成Render Tree
4. 根据Render Tree来布局，计算每个节点的位置  
5. 调用GPU渲染进程，渲染页面  

想要提高FCP的性能，我们就得快速让浏览器渲染第一个dom元素。因为浏览器中渲染进程和JS进程都是单线程的，这意味着同一时间只能执行一个任务，如果渲染进程和JS进程同时进行，会导致两者之间出现竞争条件和死锁等问题。所以在某个时刻只有一个进程处于活动状态，所以我们需要避免css，js文件阻塞渲染，其中的优化点有：

> 优化点1：异步加载或者延迟加载JS文件，让浏览器在解析HTML的同时下载JS，而不是暂停解析：  

**编译时**

1. 使用`entry`配置手动的分离代码，指定多个入口文件，每个入口文件对应一个bundle  
2. 使用`import()`动态的分离代码，让webpack自动地根据代码中的import() 语句进行代码分割，生成一个或多个chunk，可以实现按需加载或者懒加载，提高性能和用户体验  


**运行时**

1.使用async属性，让浏览器在下载js时继续解析html，但是一旦下载完成，就会暂停解析并执行脚本，这种方法适用于不依赖其他脚本的独立运行的脚本，因为他们的执行顺序时不确定的。  
2.使用defer属性，让浏览器在下载js时继续解析html，并且等待执行脚本，直到html解析完成。这种方法可以保证脚本按照他们在页面中出现的顺序执行，适用于需要等待页面解析和依赖其他脚本的情况。 
3. 让js最后加载，即将script标签放在body标签的最后面，这样可以确保在加载和执行js之前，页面的其他内容已经呈现出来。


> 优化点2：在拉入css文件的链接元素上使用media属性，以识别有条件的css资源 

在link元素上使用media属性，可以指定该元素链接的样式表或者其他资源适用于哪些媒体类型或媒体查询。这样可以让浏览器根据当前的设备或情况，选择性地加载或应用不同的资源，从而提高性能和用户体验。  


> 优化点3： 确定呈现首屏内容所需的样式，并与HTML内联发送这些样式，避免使用@import引入css


**编译时**

webpack实现 Cirtical Path CSS Generator 的一种方法是使用critters-webpack-plugin，这是一个webpack插件，可以内联你的应用的关键路劲的css，并且延迟加载剩余的css。它的工作原理是：你在webpack配置中添加这个插件，并设置一些可选的配置项，然后她会自动处理你的html文件，将关键路径css内联到head标签中，将其他css文件通过js异步加载。


**运行时**

内联首屏关键css是指对网站首屏内容进行样式设计的css，并将其放在html的head标签中的style标签里，这样可以减少http请求和渲染阻塞，提高页面的加载速度和用户体验。  



> 优化点4：移除未使用的css代码，避免加载不必要的样式 


**编译时**

使用webpack移除未使用的css代码，安装`purgecss-webpack-plugin`，可以分析html和js文件，并从css文件中删除未使用的样式 


> 优化点5： 极简化 HTML、CSS 和 JavaScript 文件，去除无关的字符和空格，减小文件大小


**编译时**

代码压缩，在webpack 5中 mode为production时会自动开启压缩，使用的两个插件  
- css-minimizer-webpack-plugin
- terser-webpack-plugin 

> 优化点6：使用CDN



















从输入 url 到看到页面的过程中，会经历：

1. 浏览器对输入的地址进行 url 解析
2. 缓存解析，如浏览器缓存，系统缓存，路由器缓存等
3. 通过 DNS 服务器将主机域名转换为 IP 地址
4. 根据 IP 地址找到对应的服务器，发起 TCP 连接
5. 建立 TCP 链接,发起 HTTP 请求
6. 服务器响应 HTTP 请求，浏览器获得 HTML 代码
7. 浏览器解析 HTML 代码，再请求代码中的资源，如 css，js，图片等
8. 浏览器解析渲染试图页面
9. 服务器断开 TCP 链接

关键词：URL 解析,DNS 解析,HTTP 协议,HTTP 缓存,TCP 连接,服务器，响应体，渲染，根据这些关键词产出性能优化策略

所以我们需要更快的网络传输，更快的数据处理，更快的渲染页面

## 更快的网络传输

1. DNS 预解析，将 link 标签的 rel 属性改成**dns-prefetch**，可以提前获取域名的 ip 地址

2. 使用缓存，减轻服务端压力，快速得到数据

3. 使用 CDN

4. 压缩响应，压缩组件通过减少 HTTP 请求的响应包的大小，从而降低传输时间的方式来提高性能

## 更快的数据处理

## 更快的渲染页面

webkit 的渲染流程

1. 解析 HTML，形成 DOM 树
2. 解析 CSS，形成 CSSOM 树
3. DOM 树和 CSSOM 树构成渲染树 render tree
4. 根据 render tree 来布局，计算每个节点的位置
5. 调用 GPU 绘制,合成图层，渲染页面

6. 避免 CSS 阻塞，css 影响 renderTree 的构建，会阻塞页面的渲染，因此应该**尽早(将 css 放在 head 标签里)和尽快(启用 CDN 实现静态资源加载速度的优化)**将 css 资源加载

7. 降低 css 选择器的复杂度，浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。

- 减少嵌套：最多不要超过三层，并且后代选择器的开销较高，慎重使用
- 避免使用通配符，对用到的元素进行匹配即可
- 利用继承，避免重复匹配和定义
- 正确使用类选择器和 id 选择器

3. 避免使用 css 表达式，css 表达式会被频繁的计算

4. 避免 js 阻塞  
   js 可以修改 cssom 和 DOM，因此 js 会阻塞页面的解析和渲染，并且会等待 css 资源的加载，也就是说 js 会抢走渲染引擎的控制权，所以我们需要给 js 资源添加 defer 和 async，延迟 js 脚本的执行

5. 使用外联式的 js 和 css  
   在现实环境中使用外部文件通常会产生较快的页面，因为 js 和 css 有机会被浏览器缓存起来。对于内联的情况，由于 html 文件通常不会被配置为可以进行缓存的，所以每次请求 html 文件都要下载 js 和 css。所以，如果 js 和 css 在外部文件，浏览器可以缓存他们，html 文件的大小会被减少而不必增加 http 请求数量

6. 使用字体图标代替图片图标，图片会增加网络请求次数，从而拖慢页面加载时间，字体图标可以很好的缩放并且不会添加额外的请求

7. 首屏加载优化，使用骨架屏或者动画优化用户体验，资源按需加载，首页不需要的资源延迟加载

8. 减少重绘和回流  
  1.opacity 触发重绘回流只有在非合成层上 否则只有重绘 没有回流（经过一个老哥的提醒 特定查了一下资料 ）
  2.visibility: hidden; 只会 重绘 不会回流
  3.display:none; 自然不用说 重绘回流都会触发

# 白屏优化
