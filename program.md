管理系统的基本功能是用户可以对数据进行增删改查，我还实现了基于角色访问控制，根据用户角色和路由权限列表动态渲染用户能够访问的菜单，也就是动态注册路由，还有就是菜单和界面的按钮等组件的权限控制，使用 axios 拦截请求，通过 token 实现权限认证。该项目我还做了挺多的性能优化：比如骨架屏，图片懒加载，路由懒加载，Tree shaking 等。
我认为我的项目难点在于：动态路由的实现和组件按钮的权限控制，以及性能优化方面。

动态路由一般有 2 种实现方式：

1. 所有子路由都会被注册，但只会显示其拥有的菜单，实现简单，但是可以通过 url 的方式去访问不能访问的页面，不安全
2. 通过菜单动态匹配路由并且注册路由，这需要和后端进行配合，需要添加一个用户菜单的字段

具体的实现方式：
通过 import.meta.glob 获取 router 下面所有的文件，对这个 files 文件对象进行遍历，拿去每个子文件的 files[key]下面的 module.default，然后将其添加到 localroutes 数组中，这样子就获取到所有的路由信息然后根据用户的权限列表字段，去该路由信息的数组匹配该用户拥有的菜单。

组件按钮的权限控制的难点在于：

1. 粒度问题：在界面权限控制中，需要对每个页面，组件，按钮等进行权限控制，以保证不同的用户角色只能看到自己具有权限的内容。在这个项目中我的解决方法是根据功能模块来进行权限配置的，将系统划分为多个功能模块，对每个功能模块进行权限配置，然后在相应页面和组件中进行判断。
2. 权限控制的实时性问题：在界面权限控制中，需要对用户的权限进行实时的验证和控制，以确保用户只能看到自己具有权限的内容。需要及时更新权限的配置。为了解决这个问题，我是通过在用户操作时向后端请求最新的权限信息，以确保用户的权限信息是最新的。

性能优化：
使用节流函数对登录逻辑进行节流，防止重复请求
骨架屏的实现原理：

1. 使用 css 绘制骨架屏的占位符，通常是一些灰色的矩形框或者线条。
2. 在页面加载时，先显示骨架屏占位符，可以使用 visibility：hidden 或者 opacity：0 来隐藏实际内容。
3. 在实际内容加载完成后，使用 js 将骨架屏占位符替换成实际内容




将token存放在localstorage中是一种常见的身份验证方案，但是需要注意的是，localstorage中的数据不会自动过期，除非手动清除或者浏览器缓存被清除。

这意味着，如果将token存放在localstorage中，可能会存在一些安全隐患。例如，如果用户在一个公共设备上登录了某个网站，那么下一个使用该设备的人也可以访问该网站，并且可以获取到该用户的token，进而冒充该用户进行恶意操作。

为了避免这种情况，可以考虑以下几种方案：

1. 将token存放在sessionStorage中。与localstorage不同，sessionStorage中的数据在会话结束时会自动清除，可以提高安全性。

2. 将token存放在cookie中，并设置过期时间。这样可以控制token的有效期，保证token不会永久存储在客户端。



> 虚拟列表

当一个页面需要渲染大量数据时，如果简单地将所有数据都渲染到DOM中，会导致页面变得非常缓慢，因为浏览器需要处理大量的DOM元素。这时候，使用虚拟列表技术可以显著提高性能，因为它只会渲染当前可见的部分数据，而不是所有的数据。

实现虚拟列表的原理是通过动态计算可见部分的数据，然后只渲染这部分数据。具体来说，一般会先计算出列表容器的高度以及每个列表项的高度，然后根据列表容器的滚动位置，计算出当前可见的列表项的索引范围。接着，只需要渲染这个索引范围内的列表项即可。

在实现虚拟列表时，通常会使用一些技术来优化性能。例如，使用定时器或者requestAnimationFrame等技术来延迟计算和渲染。另外，还可以使用缓存技术来避免重复计算和渲染已经渲染的列表项。

虚拟列表的实现方式可以因框架而异，但是基本的原理是相似的。一些流行的虚拟列表库，如react-window、react-virtualized、vue-virtual-scroller等，都是基于这个原理实现的。



> 虚拟列表 & 分页查询

虚拟列表和分页都是用于处理大量数据时的技术，它们各有优缺点，具体使用哪种技术要根据具体情况来决定。

虚拟列表的优点是，它可以在不占用过多内存的情况下，快速地渲染大量数据。相比分页，虚拟列表可以一次性加载并渲染所有数据，避免了翻页时的加载和渲染延迟，提高了用户体验。同时，虚拟列表还可以根据用户的滚动行为来动态加载和卸载数据，避免了不必要的渲染和占用内存，进一步提高了性能。

然而，虚拟列表的缺点是，它对于一些需要精确分页或者数据分组的场景不太适用。因为虚拟列表是将所有数据一次性渲染出来，无法方便地进行分组和分页。同时，虚拟列表对于一些需要进行复杂计算的场景，可能会导致性能瓶颈。

相比之下，分页技术可以方便地进行数据分组和分页，适用于需要精确分页的场景。同时，分页技术对于大量数据的加载和渲染可以进行更细粒度的控制，以避免性能问题。

综上所述，虚拟列表和分页各有优缺点，需要根据具体场景来选择使用哪种技术。如果需要处理大量数据，并且不需要进行精确分页和分组，可以考虑使用虚拟列表技术。如果需要进行精确分页和分组，或者对数据加载和渲染有更细粒度的要求，可以考虑使用分页技术。


> 虚拟列表 + 分页查询


具体来说，可以采用“虚拟分页”的方式，将虚拟列表和分页技术结合起来。在这种方式下，首先进行分页查询，然后将每一页的数据渲染到虚拟列表中。当用户翻页时，只需要在虚拟列表中切换渲染的数据，而不需要再次向服务器发起请求。这样可以避免重复查询和渲染大量的数据，提高性能和用户体验。

在实现虚拟分页时，需要考虑一些问题，比如如何计算每一页的数据量、如何计算每一页的高度等等。同时，还需要注意在用户翻页时，如何快速切换渲染的数据，以避免卡顿和延迟。

React中的`react-virtualized`和`react-window`库都提供了虚拟分页的实现方式，可以作为参考。在Vue中，可以使用`vue-virtual-scroller`库来实现虚拟列表和分页的结合。