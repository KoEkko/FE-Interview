# ES6 新特性

- 块级作用域：引入了 let 和 const，可以在块级作用域中声明变量，使得代码更加可靠且易于维护
- 箭头函数
- 模板字面量
- 解构赋值
- 默认参数
- 扩展操作符
- 类和继承
- generator 函数
- 模块化
  模块是 ES6 中引入的一个重要特性，它使得 JS 更加模块化，可复用和易用。在 ES6 之前，官方没有正式的模块特性，社区提供了两种解决方案：CommonJS 和 AMD.在 ES6 之后，官方推出了 ES Module 模块化开发。import 命令会被 JS 引擎静态分析，先于模块内的其他语句执行，import()函数支持动态加载模块。
  ES Module 和 CommonJs 的差异
  ● CommonJs 模块输出的是一个值的拷贝，ES Module 模块输出的是值的引用
  ● CommonJS 模块是运行时加载，ES6 模块是编译时输出接口
  第一个差异：CommonJS 一旦输出一个值，模块内部的变化就影响不到这个值，会被缓存，除非写成一个函数，才能得到内部变动后的值。ES 6 模块的运行机制与 CommonJS 不一样，JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用，等到脚本真正执行时，再根据这个只读引用，到被加载的哪个模块里面去取值。因此，ES Module 模块是动态引用，不会缓存值，模块里面的变量绑定其所在的模块。
  第二个差异：CommonJs 加载的是一个对象，该对象只有在脚本运行完才会生成，而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成
- 异步编程 Promise
- Proxy
- Set 和 Map

# Promise

异步编程 Promise 比传统的解决方案--回调函数和事件--更合理和强大
Promise 简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。Promise 是一个对象，从它可以获取异步操作的信息。
Promise 对象有两个特点：

1. 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending，fulfilled，rejected。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
2. 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能，从 pending 变为 fulfilled，从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，如果改变已经发生了，再对 Promise 对象添加回调函数，也会立即得到这个结果。
   有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。

promise 的缺点：

1. 无法取消 promise，一旦新建就会立即执行，无法中途取消
2. 如果不设置回调函数，promise 内部抛出错误不会放映到外部，当处于 pending 状态的时候，无法得知目前进展到哪个阶段。

# generator

# 事件循环

JS 中的事件循环机制指的是 JS 运行时如何处理事件和异步代码执行的机制，它的核心是事件循环，它是一个不断运行的循环，不断地从事件队列中取出事件并处理，直到事件队列为空。  
事件循环机制有三个重要的概念：

- 调用栈：JS 引擎用来存储函数调用栈的数据结构，当一个函数被调用的时候，它会被压入调用栈中，当函数执行完成后会从调用栈中弹出
- 任务队列：用来存放异步任务的队列，当异步任务完成时，它会被推入到任务队列中。异步任务分为宏任务和微任务，宏任务包括 SetTimeout/SetInterval,I/O 操作，事件等，他们会被放到任务队列中等待执行。微任务包括 Promise、MutationObserver 等，他们会被放入到微任务队列中等待执行，当一个宏任务执行完成后，事件循环会优先执行当前微任务队列中的所有任务，直到微任务队列为空后，再执行下一个宏任务
- 事件循环：负责不断地从任务队列中取出任务并放入调用栈中执行，直到任务队列为空为止

事件循环机制的执行流程如下：

1. 执行全局代码，创建主线程调用栈
2. 遇到异步事件，将其加入到任务队列中
3. 主线程调用栈为空时，事件循环会从任务队列中取出一个任务， 将其放入调用栈中执行
4. 当该任务执行完成后，调用栈为空，事件循环会再次从任务队列中取出一个任务，重复上述步骤

在事件循环机制中，浏览器在执行完所有的微任务后，会检查是否有需要更新的渲染任务，如果有，就会将这些渲染任务添加到渲染队列中，最后，浏览器会依次处理渲染队列中的任务，计算样式，布局和绘制，并将渲染结果显示在屏幕上。

并不是每一次事件循环机制都会出发渲染机制。渲染任务通常由异步任务出发，例如用户交互，网络请求等，只有在执行完所有的微任务后，且有需要更新的渲染任务时，才会触发渲染机制。如果没有需要更新的渲染任务，事件循环机制会继续等待下一个宏任务的到来。

如果有多个需要更新的渲染任务，它们的执行顺序通常是按照添加的顺序执行的，无法手动调整执行顺序，因为这是由浏览器内部的渲染引擎控制的，虽然不能手动调整渲染任务的执行顺序，但是可以通过优化 js 代码和渲染任务的触发方式，来优化渲染性能和用户体验。例如可以将渲染任务拆分成多个小任务，通过 requestAnimationFrame 等 api 分批执行，以保证及时响应渲染任务的更新请求。

# 闭包

闭包就是一个函数可以访问外部的自由变量，就叫闭包。

闭包的经典应用场景就是防抖和节流

# this 指向

# new 的过程

1. 在内存中开辟一段新的空间，创建一个新的对象
2. 该对象的隐式原型指向构造函数的显示原型
3. 构造函数中的 this 指向新创建的对象
4. 执行构造函数中的代码
5. 如果构造函数没有返回非空对象，则返回新创建的对象

# 捕获和冒泡

# 原型与原型链

在 js 中，每个对象都有一个原型对象，原型对象又有自己的原型对象，这样就形成了一个原型链。原型链是一个对象属性的查找机制，如果一个对象无法在自身属性中找到某个属性，那么它会去它的原型对象中查找，如果还找不到，就会继续往原型链上层查找，直到找到该属性或者到达原型链的顶层。

一个对象的原型可以通过**proto**属性来访问，也可以通过 Object.getPrototypeOf()。

原型对象可以用来实现继承，通过让一个构造函数的原型对象指向另一个构造函数的实例，可以让一个对象从另一个对象中继承属性和方法。

# 防抖节流的实现

```js
// 防抖
function debounce(fn, delay) {
  let timer = null;
  return function (...args) {
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 节流
function throttle(fn, delay) {
  let waiting = false,
    lastArgs = null;

  return function (...args) {
    if (!waiting) {
      fn.apply(this, args);
      waiting = true;
      let timeout = () =>
        setTimeout(() => {
          waiting = false;
          if (lastArgs) {
            fn.apply(this, lastArgs);
            waiting = true;
            lastArgs = null;
            timeout();
          }
        }, delay);
      timeout();
    } else {
      lastArgs = args;
    }
  };
}
```

# 深拷贝和浅拷贝

# call,apply,bind 函数

# 箭头函数和普通函数的区别

1. 箭头函数可以更简洁的定义函数。可以省略函数关键字 function，花括号，和 return 关键字，如果函数只有一个表达式，则可以直接返回它
2. 箭头函数的 this 关键字指向的是定义函数时所在的作用域，即父级作用域，而不是调用时所在的作用域，普通函数的 this 指向的是调用该函数的对象
3. 箭头函数不能使用 arguments 关键字来访问函数参数，但是可以使用剩余参数语法来获取所有参数
4. 箭头函数不能用作构造函数，不能使用 new 关键字创建对象
5. 箭头函数没有 prototype 属性，因此不能定义原型方法
6. 箭头函数不绑定自己的 arguments 对象，因此访问 arguments 会引用父级作用域中的 arguments 对象

# localStorage 和 sessionStorage 的区别

localStorage 和 sessionStorage 都是用来存储数据的方法，他们都可以在浏览器端存储数据，而且都是以键值对的形式存储

他们的区别在于：

1. 存储数据的生命周期不同：localStorage 存储的数据没有过期时间，会一直存在与浏览器中，直到被手动删除；而 sessionStorage 存储的数据只在当前会话下有效，当用户关闭浏览器窗口或标签页时，数据会被清除。
2. 存储数据的作用域不同：localStorage 存储的数据在同一域名下的所有页面都可以共享访问；而 sessionStorage 存储的数据只能在同一浏览器窗口或标签页中共享访问，不同窗口或标签页之间的数据是隔离的。
3. 存储数据的大小限制不同：localStorage 的存储容量一般比 sessionStorage 大，可以存储更多的数据，但具体容量限制因浏览器而异

# 递归遇到循环引用怎么办

# JSON.stringfy()方法有什么缺点

# 浏览器输入一个 URL 会经历什么

# 浏览器缓存

浏览器缓存是指浏览器在访问网页时，会将一些静态资源缓存在本地硬盘或内存中，以便下次访问同一网页时可以直接从缓存中获取资源，从而提高访问速度和用户体验。

浏览器缓存分为强缓存和协商缓存

1. 强缓存：浏览器在第一次请求资源的时候，会先检查该资源的缓存标识（如 HTTP 头中的 Cache-Control 和 Expires 字段），如果缓存标识在规定的时间范围内有效，则直接从缓存中获取资源，不再向服务器发送请求，这样可以快速加载页面。
2. 协商缓存：当强缓存失效时，浏览器会向服务器发送一个请求，询问该资源是否有更新。服务器会检查资源的最后修改时间（如 HTTP 头中的 Last-Modified 字段）和 ETag 值（如 HTTP 头中的 ETag 字段）等信息，如果资源没有更新，则服务器返回 304 状态码，告诉浏览器可以使用本地缓存的资源，否则返回新的资源内容

# SSR 原理

# WebSocket 通信原理

# promise.then 里面一直调用自身会不会阻塞

如果 promise.then()中一直调用自身，那么会导致 JS 运行时出现栈溢出错误，因为每次调用都会在调用栈中创建一个新的函数调用帧，而调用栈的大小是有限制的，当调用栈的大小超过限制时，就会抛出栈溢出错误。

如果需要递归处理 Promise，可以使用递归函数，并且在递归函数中返回 Promise 对象，然后在 Promise 链中使用 promise.then()来处理结果，而不是在函数内部一直调用自身
