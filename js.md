# ES6新特性


- 块级作用域：引入了let和const，可以在块级作用域中声明变量，使得代码更加可靠且易于维护
- 箭头函数
- 模板字面量
- 解构赋值
- 默认参数
- 扩展操作符
- 类和继承
- generator函数
- 模块化
模块是ES6中引入的一个重要特性，它使得JS更加模块化，可复用和易用。在ES6之前，官方没有正式的模块特性，社区提供了两种解决方案：CommonJS和AMD.在ES6之后，官方推出了ES Module模块化开发。import命令会被JS引擎静态分析，先于模块内的其他语句执行，import()函数支持动态加载模块。
ES Module 和 CommonJs的差异
● CommonJs模块输出的是一个值的拷贝，ES Module模块输出的是值的引用
● CommonJS模块是运行时加载，ES6模块是编译时输出接口
第一个差异：CommonJS一旦输出一个值，模块内部的变化就影响不到这个值，会被缓存，除非写成一个函数，才能得到内部变动后的值。ES 6模块的运行机制与CommonJS不一样，JS引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用，等到脚本真正执行时，再根据这个只读引用，到被加载的哪个模块里面去取值。因此，ES Module模块是动态引用，不会缓存值，模块里面的变量绑定其所在的模块。
第二个差异：CommonJs加载的是一个对象，该对象只有在脚本运行完才会生成，而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成
- 异步编程 Promise
- Proxy
- Set 和 Map



# Promise


异步编程Promise 比传统的解决方案--回调函数和事件--更合理和强大
Promise简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。Promise是一个对象，从它可以获取异步操作的信息。
Promise对象有两个特点：
1. 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending，fulfilled，rejected。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
2. 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能，从pending变为fulfilled，从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，如果改变已经发生了，再对Promise对象添加回调函数，也会立即得到这个结果。
有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。

promise的缺点：
1. 无法取消promise，一旦新建就会立即执行，无法中途取消
2. 如果不设置回调函数，promise内部抛出错误不会放映到外部，当处于pending状态的时候，无法得知目前进展到哪个阶段。


# generator


# 事件循环

JS中的事件循环机制指的是JS运行时如何处理事件和异步代码执行的机制，它的核心是事件循环，它是一个不断运行的循环，不断地从事件队列中取出事件并处理，直到事件队列为空。  
事件循环机制有三个重要的概念：  
- 调用栈：JS引擎用来存储函数调用栈的数据结构，当一个函数被调用的时候，它会被压入调用栈中，当函数执行完成后会从调用栈中弹出
- 任务队列：用来存放异步任务的队列，当异步任务完成时，它会被推入到任务队列中。异步任务分为宏任务和微任务，宏任务包括SetTimeout/SetInterval,I/O操作，事件等，他们会被放到任务队列中等待执行。微任务包括Promise、MutationObserver等，他们会被放入到微任务队列中等待执行，当一个宏任务执行完成后，事件循环会优先执行当前微任务队列中的所有任务，直到微任务队列为空后，再执行下一个宏任务
- 事件循环：负责不断地从任务队列中取出任务并放入调用栈中执行，直到任务队列为空为止  

事件循环机制的执行流程如下：  
1. 执行全局代码，创建主线程调用栈
2. 遇到异步事件，将其加入到任务队列中  
3. 主线程调用栈为空时，事件循环会从任务队列中取出一个任务， 将其放入调用栈中执行  
4. 当该任务执行完成后，调用栈为空，事件循环会再次从任务队列中取出一个任务，重复上述步骤  


# 闭包


# this指向


# new的过程

1. 在内存中开辟一段新的空间，创建一个新的对象
2. 该对象的隐式原型指向构造函数的显示原型
3. 构造函数中的this指向新创建的对象
4. 执行构造函数中的代码
5. 如果构造函数没有返回非空对象，则返回新创建的对象

# 捕获和冒泡


# 原型与原型链


# 防抖节流的实现



# 深拷贝和浅拷贝


# call,apply,bind 函数


# 箭头函数和普通函数的区别


1. 箭头函数可以更简洁的定义函数。可以省略函数关键字function，花括号，和return关键字，如果函数只有一个表达式，则可以直接返回它
2. 箭头函数的this关键字指向的是定义函数时所在的作用域，即父级作用域，而不是调用时所在的作用域，普通函数的this指向的是调用该函数的对象 
3. 箭头函数不能使用arguments关键字来访问函数参数，但是可以使用剩余参数语法来获取所有参数
4. 箭头函数不能用作构造函数，不能使用new关键字创建对象
5. 箭头函数没有prototype属性，因此不能定义原型方法
6. 箭头函数不绑定自己的arguments对象，因此访问arguments会引用父级作用域中的arguments对象

# localStorage 和 sessionStorage 的区别
  

# 递归遇到循环引用怎么办


# JSON.stringfy()方法有什么缺点


# 浏览器输入一个URL会经历什么


# 浏览器缓存


# SSR原理


# WebSocket通信原理


# promise.then里面一直调用自身会不会阻塞


如果promise.then()中一直调用自身，那么会导致JS运行时出现栈溢出错误，因为每次调用都会在调用栈中创建一个新的函数调用帧，而调用栈的大小是有限制的，当调用栈的大小超过限制时，就会抛出栈溢出错误。  

如果需要递归处理Promise，可以使用递归函数，并且在递归函数中返回Promise对象，然后在Promise链中使用promise.then()来处理结果，而不是在函数内部一直调用自身

